# Консоль Artisan

- [Введение](#introduction)
    - [Tinker (REPL)](#tinker)
- [Написание команд](#writing-commands)
    - [Создание команд](#generating-commands)
    - [Структура команды](#command-structure)
    - [Анонимные команды](#closure-commands)
- [Определение вводимых данных](#defining-input-expectations)
    - [Аргументы](#arguments)
    - [Параметры](#options)
    - [Массивы данных](#input-arrays)
    - [Описания вводимых данных](#input-descriptions)
- [Ввод/вывод команды](#command-io)
    - [Получение входных данных](#retrieving-input)
    - [Запрос для ввода данных](#prompting-for-input)
    - [Вывод данных](#writing-output)
- [Регистрация команд](#registering-commands)
- [Программное выполнение команд](#programmatically-executing-commands)
    - [Вызов команд из других команд](#calling-commands-from-other-commands)
- [Настройка заглушек](#stub-customization)
- [События](#events)

<a name="introduction"></a>
## Введение

Artisan — это интерфейс командной строки, входящий в состав Laravel. Он предоставляет ряд полезных команд, которые помогут при создании приложения. Для просмотра списка всех доступных команд Artisan можно использовать команду `list`:

    php artisan list

Каждая команда также включает в себя экран «справки», который отображает и описывает доступные аргументы и параметры команды. Чтобы просмотреть экран справки, используйте `help` перед именем команды:

    php artisan help migrate

<a name="tinker"></a>
### Tinker (REPL)

Laravel Tinker — это мощный REPL для фреймворка Laravel, основанный на пакете [PsySH](https://github.com/bobthecow/psysh).

<a name="installation"></a>
#### Установка

Все приложения Laravel по умолчанию включают Tinker. Однако, при необходимости вы можете установить его вручную, используя Composer:

    composer require laravel/tinker

> {tip} Ищете графический интерфейс для взаимодействия с приложением Laravel? Зацените [Tinkerwell](https://tinkerwell.app)!

<a name="usage"></a>
#### Использование

Tinker позволяет взаимодействовать полностью со всем приложением Laravel из командной строки, включая Eloquent ORM, задачи, события и многое другое. Чтобы войти в среду Tinker, выполните команду Artisan `tinker`:

    php artisan tinker

Вы можете опубликовать файл конфигурации Tinker с помощью команды `vendor:publish`:

    php artisan vendor:publish --provider="Laravel\Tinker\TinkerServiceProvider"

> {note} Глобальный помощник `dispatch` и метод `dispatch` в классе `Dispatchable` зависят от "garbage collection" для помещения задания в очередь. Следовательно, при использовании Tinker вы должны использовать `Bus::dispatch` или `Queue::push` для отправки заданий.

<a name="command-whitelist"></a>
#### Белый список команд

Tinker использует белый список, чтобы определить, какие команды Artisan разрешено запускать в её среде. По умолчанию вы можете запускать команды `clear-compiled`, `down`, `env`, `inspire`, `migrate`, `optimize` и `up`. Для добавления в белый список больше команд, добавьте их в массив `commands` в файле конфигурации `tinker.php`:

    'commands' => [
        // App\Console\Commands\ExampleCommand::class,
    ],

<a name="classes-that-should-not-be-aliased"></a>
#### Черный список псевдонимов

Как правило, Tinker автоматически создает псевдонимы классов. Тем не менее, вы можете запретить такое поведение для некоторых классов, перечислив их в массиве `dont_alias` файла конфигурации `tinker.php`:

    'dont_alias' => [
        App\Models\User::class,
    ],

<a name="writing-commands"></a>
## Написание команд

В дополнение к командам Artisan, вы можете создавать пользовательские команды. Команды обычно хранятся в каталоге `app/Console/Commands`; однако, вы можете выбрать другое месторасположение, если эти команды могут быть загружены менеджером Composer.

<a name="generating-commands"></a>
### Создание команд

Для создания новой команды используйте Artisan команду `make:command`. Эта команда создаст новый класс команды в каталоге `app/Console/Commands`. Не волнуйтесь, если этот каталог не существует в вашем приложении, так как он будет создан при первом запуске Artisan команды `make:command`. Сгенерированная команда будет включать набор свойств и методов по умолчанию, присутствующих во всех командах:

    php artisan make:command SendEmails

<a name="command-structure"></a>
### Структура команды

После создания команды следует заполнить свойства класса `signature` и `description`, которые будут отображаться на экране при использовании команды `list`. Метод `handle` будет вызываться при выполнении команды. Вы можете разместить логику команды в этом методе.

> {tip} Хорошей практикой повторного использования кода считается создание «простых» консольных команд с делегированием своих задач службам приложения. В приведенном ниже примере мы внедряем класс службы для выполнения «затратной» отправки электронных писем.

Давайте рассмотрим пример команды. Обратите внимание, что мы можем внедрять любые необходимые зависимости в методе `handle` команды. [Контейнер служб](container.md) Laravel автоматически внедрит все зависимости, типы которых объявлены в этом методе:

    <?php

    namespace App\Console\Commands;

    use App\Models\User;
    use App\Support\DripEmailer;
    use Illuminate\Console\Command;

    class SendEmails extends Command
    {
        /**
         * Имя и сигнатура консольной команды.
         *
         * @var string
         */
        protected $signature = 'email:send {user}';

        /**
         * Описание консольной команды.
         *
         * @var string
         */
        protected $description = 'Send drip e-mails to a user';

        /**
         * Создать новый экземпляр команды.
         *
         * @return void
         */
        public function __construct()
        {
            parent::__construct();
        }

        /**
         * Выполнить консольную команду.
         *
         * @param  \App\Support\DripEmailer  $drip
         * @return mixed
         */
        public function handle(DripEmailer $drip)
        {
            $drip->send(User::find($this->argument('user')));
        }
    }

<a name="closure-commands"></a>
### Анонимные команды

Команды на основе замыкания обеспечивают альтернативу определению консольных команд в виде классов. Точно так же, как замыкания маршрутов являются альтернативой контроллерам. В рамках метода `commands` файла `app/Console/Kernel.php` Laravel загружает файл `routes/console.php`:

    /**
     * Зарегистрировать команды, основанные на анонимных функциях.
     *
     * @return void
     */
    protected function commands()
    {
        require base_path('routes/console.php');
    }

Хотя этот файл не определяет маршруты HTTP, он определяет точки входа (маршруты) для консольных команд в приложении. В этом файле с помощью метода `Artisan::command` можно определить все маршруты на основе замыканий. Метод `command` принимает два аргумента: [сигнатуру команды](#defining-input-expectations) и замыкание, которое получает аргументы и параметры команды:

    Artisan::command('build {project}', function ($project) {
        $this->info("Building {$project}!");
    });

Замыкание привязано к базовому экземпляру команды, поэтому у вас есть полный доступ ко всем вспомогательным методам, к которым вы обычно можете обращаться в команде, созданной с помощью класса.

<a name="type-hinting-dependencies"></a>
#### Типизация зависимостей

Помимо получения аргументов и параметров, замыкание анонимной команды также принимает дополнительные зависимости из [контейнера служб](container.md), необходимые для внедрения:

    use App\Models\User;
    use App\Support\DripEmailer;

    Artisan::command('email:send {user}', function (DripEmailer $drip, $user) {
        $drip->send(User::find($user));
    });

<a name="closure-command-descriptions"></a>
#### Описания анонимных команд

При определении анонимных команд, можно использовать метод `describe` для добавления описания команды. Это описание будет отображаться при запуске команд `php artisan list`, `php artisan help`:

    Artisan::command('build {project}', function ($project) {
        $this->info("Building {$project}!");
    })->describe('Build the project');

<a name="defining-input-expectations"></a>
## Определение вводимых данных

При написании консольных команд обычно происходит сбор данных, получаемых от пользователя, с помощью аргументов или параметров. Laravel позволяет очень удобно определять входные данные, которые вы ожидаете от пользователя, используя свойство `signature` команд. Свойство `signature` позволяет определить имя, аргументы и параметры команды в едином выразительном синтаксисе, схожим на синтаксис маршрутов.

<a name="arguments"></a>
### Аргументы

Все предоставленные пользователем аргументы и параметры заключаются в фигурные скобки. В следующем примере команда определяет один **обязательный** аргумент `user`:

    /**
     * Имя и сигнатура консольной команды.
     *
     * @var string
     */
    protected $signature = 'email:send {user}';

По желанию можно сделать аргументы необязательными или определить значения по умолчанию:

    // Необязательный аргумент ...
    email:send {user?}

    // Необязательный аргумент с заданным по умолчанию значением ...
    email:send {user=foo}

<a name="options"></a>
### Параметры

Параметры, как и аргументы, являются разновидностью пользовательского ввода. Параметры должны иметь префикс в виде двух дефисов (`--`), когда они указаны в командной строке. Существует два типа параметров: те, которые получают значение, и те, которые его не получают. Параметры, которые не получают значение, служат логическим «переключателем». Давайте рассмотрим пример такого варианта:

    /**
     * Имя и сигнатура консольной команды.
     *
     * @var string
     */
    protected $signature = 'email:send {user} {--queue}';

В этом примере при вызове команды Artisan может быть указан переключатель `--queue`. Если переключатель `--queue` передан, значение этого параметра будет `true`. В противном случае значение будет `false`:

    php artisan email:send 1 --queue

<a name="options-with-values"></a>
#### Параметры со значениями

Давайте рассмотрим параметр, который ожидает значение. Если пользователь должен указать значение для параметра, добавьте суффикс `=` к имени параметра:

    /**
     * Имя и сигнатура консольной команды.
     *
     * @var string
     */
    protected $signature = 'email:send {user} {--queue=}';

В этом примере пользователь может передать значение для параметра:

    php artisan email:send 1 --queue=default

Параметру можно присвоить значение по умолчанию, указав его после имени. Если значение параметра не передано пользователем, будет использовано значение по умолчанию:

    email:send {user} {--queue=default}

<a name="option-shortcuts"></a>
#### Псевдонимы параметров

Чтобы назначить псевдоним при определении параметра, вы можете указать его перед именем параметра и использовать разделитель `|` для отделения псевдонима от полного имени параметра:

    email:send {user} {--Q|queue}

<a name="input-arrays"></a>
### Массивы данных

По желанию можно определить, что аргументы или параметры ожидают массив данных, вы можете использовать метасимвол `*`. Во-первых, давайте рассмотрим пример, в котором описывается аргумент как массив данных:

    email:send {user*}

При вызове этого метода аргументы `user` могут передаваться по порядку в командную строку. Например, следующая команда установит значение `user` как `['foo', 'bar']`:

    php artisan email:send foo bar

При определении параметра, ожидающего массив, каждое значение параметра, передаваемое команде, должно иметь префикс с именем параметра:

    email:send {user} {--id=*}

    php artisan email:send --id=1 --id=2

<a name="input-descriptions"></a>
### Описания вводимых данных

Вы можете назначить описания входным аргументам и параметрам, отделив параметр от описания с помощью двоеточия. Если вам нужно немного больше места для определения вашей команды, не стесняйтесь распределить определение на несколько строк:ы

    /**
     * Имя и сигнатура консольной команды.
     *
     * @var string
     */
    protected $signature = 'email:send
                            {user : The ID of the user}
                            {--queue= : Whether the job should be queued}';

<a name="command-io"></a>
## Ввод/вывод команды

<a name="retrieving-input"></a>
### Получение входных данных

Во время выполнения команды вам, очевидно, потребуется получить доступ к значениям аргументов и параметров, принятых командой. Для этого вы можете использовать методы `argument` и `option`:

    /**
     * Выполнить консольную команду.
     *
     * @return mixed
     */
    public function handle()
    {
        $userId = $this->argument('user');

        //
    }

Если вам нужно получить все аргументы в виде массива, вызовите метод `arguments`:

    $arguments = $this->arguments();

Параметры могут быть получены так же легко, как и аргументы, используя метод `option`. Чтобы получить все параметры в виде массива, вызовите метод `options`:

    // Получение определенного параметра ...
    $queueName = $this->option('queue');

    // Получение всех параметров ...
    $options = $this->options();

Если аргумент или параметр не существует, то будет возвращено значение `null`.

<a name="prompting-for-input"></a>
### Запрос для ввода данных

Помимо отображения вывода, вы можете попросить пользователя предоставить данные во время выполнения вашей команды. Метод `ask` отобразит пользователю указанный вопрос, примет его ввод, а затем вернет эти данные, полученные от пользователя, обратно в команду:

    /**
     * Выполнить консольную команду.
     *
     * @return mixed
     */
    public function handle()
    {
        $name = $this->ask('What is your name?');
    }

Метод `secret` похож на `ask`, но ввод пользователя не будет виден ему в консоли при вводе. Этот метод полезен при запросе конфиденциальной информации, такой как пароль:

    $password = $this->secret('What is the password?');

<a name="asking-for-confirmation"></a>
#### Запрос подтверждения

Если вам нужно получить от пользователя простое подтверждение, то вы можете использовать метод `confirm`. По умолчанию этот метод возвращает значение `false`. Однако, если пользователь вводит `y` или `yes` в ответ на запрос, то метод возвращает `true`.

    if ($this->confirm('Do you wish to continue?')) {
        //
    }

<a name="auto-completion"></a>
#### Автозавершение

Метод `anticipate` может использоваться для автоматического завершения возможных вариантов. Пользователь по-прежнему может выбрать любой ответ, независимо от подсказок автозаполнения:

    $name = $this->anticipate('What is your name?', ['Taylor', 'Dayle']);

В качестве альтернативы, вы можете передать замыкание в качестве второго аргумента метода `anticipate`. Замыкание будет вызываться каждый раз, когда пользователь вводит символ. Замыкание должно принимать строковый параметр, содержащий введенные пользователем данные, и возвращать массив опций для автозаполнения:

    $name = $this->anticipate('What is your name?', function ($input) {
        // Вернуть варианты для автоматического завершения ...
    });

<a name="multiple-choice-questions"></a>
#### Вопросы с множественным выбором

Если нужно предоставить пользователю предопределенный набор вариантов для выбора, то используйте метод `choice`. Вы можете установить индекс массива для возвращаемого значения по умолчанию, если не выбран ни один из вариантов:

    $name = $this->choice('What is your name?', ['Taylor', 'Dayle'], $defaultIndex);

Кроме того, метод `choice` принимает необязательные четвертый и пятый аргументы для определения максимального количества попыток выбора действительного ответа и того, разрешен ли множественный выбор:

    $name = $this->choice(
        'What is your name?',
        ['Taylor', 'Dayle'],
        $defaultIndex,
        $maxAttempts = null,
        $allowMultipleSelections = false
    );

<a name="writing-output"></a>
### Вывод данных

Чтобы вывести в консоль, используйте методы `line`, `info`, `comment`, `question` and `error`. Каждый из этих методов будет использовать соответствующие ANSI-цвета. Например, давайте покажем пользователю некоторую общую информацию. Обычно метод `info` отображается в консоли в виде зеленого текста:

    /**
     * Выполнить консольную команду.
     *
     * @return mixed
     */
    public function handle()
    {
        $this->info('Display this on the screen');
    }

Для отображения сообщения об ошибке используйте метод `error`. Текст сообщения об ошибке обычно отображается красным цветом:

    $this->error('Something went wrong!');

Если вы хотите вывести простое, неокрашенное сообщение, используйте метод `line`:

    $this->line('Display this on the screen');

Вы можете использовать метод `newLine` для отображения пустой строки:

    $this->newLine();

    // Вывести три пустые строки ...
    $this->newLine(3);

<a name="table-layouts"></a>
#### Таблицы

Метод `table` позволяет легко форматировать несколько строк / столбцов данных. Просто передайте заголовки и строки в метод. Ширина и высота будут динамически рассчитаны на основе данных:

    $headers = ['Name', 'Email'];

    $users = App\Models\User::all(['name', 'email'])->toArray();

    $this->table($headers, $users);

<a name="progress-bars"></a>
#### Индикаторы выполнения

Для длительно выполняемых задач было бы полезно показать индикатор выполнения. Используя объект вывода, мы можем запустить, продвинуть и остановить индикатор выполнения. Во-первых, определите общее количество шагов процесса. Затем продвигайте индикатор выполнения после обработки каждого из них:

    $users = App\Models\User::all();

    $bar = $this->output->createProgressBar(count($users));

    $bar->start();

    foreach ($users as $user) {
        $this->performTask($user);

        $bar->advance();
    }

    $bar->finish();

Для получения дополнительной информации ознакомьтесь с [разделом документации компонента Symfony Progress Bar](https://symfony.com/doc/current/components/console/helpers/progressbar.html).

<a name="registering-commands"></a>
## Регистрация команд

Благодаря вызову метода `load` в методе `commands` ядра консоли все команды в каталоге `app/Console/Commands` будут автоматически зарегистрированы в Artisan. Фактически, вы можете делать дополнительные вызовы метода `load` для сканирования других каталогов на наличие команд Artisan:

    /**
     * Зарегистрировать команды приложения.
     *
     * @return void
     */
    protected function commands()
    {
        $this->load(__DIR__.'/Commands');
        $this->load(__DIR__.'/MoreCommands');

        // ...
    }

Вы можете самостоятельно зарегистрировать команды, добавив название класса в свойство `$commands` файла `app/Console/Kernel.php`. При загрузке Artisan, все команды, перечисленные в этом свойстве будут доступны в [контейнере служб](container.md) и зарегистрированы в Artisan:

    protected $commands = [
        Commands\SendEmails::class
    ];

<a name="programmatically-executing-commands"></a>
## Программное выполнение команд

По желанию можно выполнить команду Artisan за пределами CLI. Например, вы можете запустить команду Artisan в маршруте или контроллере. Для этого можно использовать метод `call` фасада `Artisan`. Метод `call` принимает в качестве первого аргумента имя или класс команды, а в качестве второго — массив параметров команды. Будет возвращен код выхода (код возврата):

    Route::get('/foo', function () {
        $exitCode = Artisan::call('email:send', [
            'user' => 1, '--queue' => 'default'
        ]);

        //
    });

Кроме того, вы можете передать всю команду методу `call` в виде строки:

    Artisan::call('email:send 1 --queue=default');

Используя метод `queue` фасада `Artisan`, вы можете даже поставить команды Artisan в очередь, чтобы они обрабатывались в фоновом режиме [обработчиком очереди](queues.md). Перед использованием этого метода убедитесь, что вы настроили очереди и запущен слушатель очереди:

    Route::get('/foo', function () {
        Artisan::queue('email:send', [
            'user' => 1, '--queue' => 'default'
        ]);

        //
    });

Вы также можете указать соединение или очередь, в которую должна быть отправлена команда Artisan:

You may also specify the connection or queue the Artisan command should be dispatched to:

    Artisan::queue('email:send', [
        'user' => 1, '--queue' => 'default'
    ])->onConnection('redis')->onQueue('commands');

<a name="passing-array-values"></a>
#### Передача массива значений

Если ваша команда определяет параметр, который принимает массив, вы можете передать массив значений этому параметру:

    Route::get('/foo', function () {
        $exitCode = Artisan::call('email:send', [
            'user' => 1, '--id' => [5, 13]
        ]);
    });

<a name="passing-boolean-values"></a>
#### Передача значений логического типа

Если необходимо указать значение параметра, который не принимает строковые значения, например флаг `--force` в команде `migrate:refresh`, то вы должны передать `true` или `false`:

    $exitCode = Artisan::call('migrate:refresh', [
        '--force' => true,
    ]);

<a name="calling-commands-from-other-commands"></a>
### Вызов команд из других команд

По желанию можно вызвать другие команды из существующей команды Artisan. Вы можете сделать это с помощью метода `call`. Метод `call` принимает имя команды и массив параметров команды:

    /**
     * Выполнить консольную команду.
     *
     * @return mixed
     */
    public function handle()
    {
        $this->call('email:send', [
            'user' => 1, '--queue' => 'default'
        ]);

        //
    }

Если вы хотите вызвать другую консольную команду в тихом режиме, то используйте метод `callSilent`. Метод `callSilent` имеет ту же сигнатуру, что и метод `call`:

    $this->callSilent('email:send', [
        'user' => 1, '--queue' => 'default'
    ]);

<a name="stub-customization"></a>
## Настройка заглушек

Команды `make` консоли Artisan используются для создания различных классов, таких как контроллеры, задания, миграции и тесты. Эти классы создаются с помощью файлов «заглушек», которые заполняются значениями на основе ваших входных данных. Однако, иногда может потребоваться внести небольшие изменения в файлы, созданные Artisan. Для этого можно использовать команду `stub:publish`, чтобы опубликовать наиболее распространенные заглушки для настройки:

    php artisan stub:publish

Опубликованные заглушки будут расположены в каталоге `stubs` корня вашего приложения. Любые изменения, внесенные вами в эти заглушки, будут отражены при создании соответствующих классов с помощью команд Artisan `make`.

<a name="events"></a>
## События

Artisan запускает три события при выполнении команд: `Illuminate\Console\Events\ArtisanStarting`, `Illuminate\Console\Events\CommandStarting`, and `Illuminate\Console\Events\CommandFinished`. Событие `ArtisanStarting` выполняется сразу после запуска Artisan. Затем событие `CommandStarting` выполняется непосредственно перед запуском команды. Наконец, событие `CommandFinished` выполняется после завершения команды.
